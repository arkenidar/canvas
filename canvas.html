<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
    <title> canvas and computed geometric boundaries for display Input/Output </title>
</head>
<body>

<div><canvas id="canvas_element"></canvas></div>
<style>
canvas#canvas_element { border: 1px solid black; }
</style>

<h1>canvas and computed geometric boundaries for Input/Output in display</h1>

<div class="text">
<div>learning again, repetition to improve.</div>
<div>past works of mine: <a>https://arkenidar.com/web/canvas/</a> </div>
<div>orientation toward:</div>
<div>this in HTML5... -> <a>https://replit.com/@dariocangialosi/circles</a> </div>
<div>novelty: a boolean function that answers the question of whether a coordinate is inside a "rounded-corners" boundary. <br>
this should extend-and-include the drawing functionality (produce visual *output* for user) <br>
to "touch in boundary" check also (user *input* checks).</div>
<a>https://www.facebook.com/dario.cangialosi.arkenidar/posts/pfbid02fL1jiy9WDr7EjAYJyMaAuXWeKGkt8qyMKikLX1JLohz39akU7KNLJH9wHyDjHbEql</a>
</div>
<script>
var links = document.querySelectorAll(".text a")
for(var link of links) link.href=link.innerText
</script>

<script>

// sizing
canvas_element.width=canvas_element.parentElement.clientWidth
canvas_element.height=canvas_element.parentElement.clientHeight

// drawing APIs
var canvas_context=canvas_element.getContext('2d')
function draw_pixel(x,y){
    canvas_context.fillRect(x,y,1,1)
}
function draw_rectangle(xywh){
    canvas_context.fillRect(...xywh)
}

// compute

function point_add(p1,p2){
    return [p1[0]+p2[0], p1[1]+p2[1]]
}

var booleans=[
    [0,0],
    [1,0],
    [0,1],
    [1,1]
]

function rectangle_point_vertex(xywh,i){
    var [x,y,w,h] = xywh
    var boolean = booleans[i]
    return [x+boolean[0]*w,y+boolean[1]*h]
}

function rectangle_point_inner_vertex_corner_box(point_vertex, radius, i){
    var boolean_pairs = [
        [0,0],
        [-radius,0],
        [0,-radius],
        [-radius,-radius]
    ]
    var translate = boolean_pairs[i]
    var point_returned = point_add(point_vertex, translate)
    return point_returned
}
function rectangle_point_inner_vertex_center(point_vertex, radius, i){
    var boolean_pairs = [
        [radius,radius],
        [-radius,radius],
        [radius,-radius],
        [-radius,-radius]
    ]
    var translate = boolean_pairs[i]
    var point_returned = point_add(point_vertex, translate)
    return point_returned
}

var rectangle=[10,10,60,100]
///draw_rectangle(rectangle) // test

var radiuses=[30,30,10,10]
///draw_corners(rectangle, radiuses) // test

var corners = compute_corners(rectangle, radiuses)
///draw_computed_corners(corners) // test

// test (main test)
var [x,y,w,h] = rectangle
for(var px = x; px < x+w; px++)for(var py = y; py < y+h; py++){
    var inside = boundary_check(rectangle, corners, [px,py])
    if(inside) draw_pixel(px, py)
}

// the central part of this exercise

function boundary_check(rectangle, corners, point){
    if(false==point_inside_rectangle(point, rectangle)) return false // outside
    for(var i=0; i<4; i++){
        var corner=corners[i]
        var outside
        outside = point_inside_rectangle(point, corner.box)
            && (distance(corner.center,point) > corner.radius)
        if(outside){
            return false // outside
        }
    }
    return true // inside
}

// corners

function draw_corners(rectangle, radiuses){
    for(var i=0; i<4; i++){
        var radius = radiuses[i]
        var point_vertex = rectangle_point_vertex(rectangle,i)

        canvas_context.fillStyle="orange"
        var point_corner_box = rectangle_point_inner_vertex_corner_box(point_vertex, radius, i)
        draw_rectangle([...point_corner_box,radius,radius])
        
        canvas_context.fillStyle="red"
        var point_center = rectangle_point_inner_vertex_center(point_vertex, radius, i)
        draw_rectangle([...point_add(point_center,[-2,-2]),4,4])
    }
}

function compute_corners(rectangle, radiuses){
    var corners = []
    for(var i=0; i<4; i++){
        var radius = radiuses[i]
        var point_vertex = rectangle_point_vertex(rectangle,i)
        var point_corner_box = rectangle_point_inner_vertex_corner_box(point_vertex, radius, i)
        var point_corner_center = rectangle_point_inner_vertex_center(point_vertex, radius, i)
        var corner = {center: point_corner_center, box: [...point_corner_box,radius,radius], radius }
        corners.push(corner)
    }
    return corners
}

function draw_computed_corners(corners){
    for(var i=0; i<4; i++){
        var corner = corners[i]

        canvas_context.fillStyle="orange"
        draw_rectangle(corner.box)
        
        canvas_context.fillStyle="red"
        draw_rectangle([...point_add(corner.center,[-2,-2]),4,4])
    }
}

// mathematic utilities

function point_inside_rectangle(point, rectangle){
  return (
    point[0]>=rectangle[0] &&
    point[0]<=(rectangle[0]+rectangle[2]) &&
    point[1]>=rectangle[1] &&
    point[1]<=(rectangle[1]+rectangle[3])
  )
}

function distance(p1,p2){
    return Math.sqrt( (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 )
}

</script>

</body>
</html>
